{"ast":null,"code":"// Feature Flags Service for Frontend Integration\n// TypeScript implementation with React support\n\nclass FeatureFlagService {\n  constructor(baseURL = '/api/v1/flags') {\n    this.baseURL = void 0;\n    this.cache = void 0;\n    this.cacheTimeout = void 0;\n    this.defaultTimeout = void 0;\n    this.baseURL = baseURL;\n    this.cache = new Map();\n    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes\n    this.defaultTimeout = 3000; // 3 seconds\n  }\n\n  /**\n   * Evaluate a single feature flag\n   */\n  async evaluateFlag(flagId, userContext) {\n    const cacheKey = `${flagId}-${JSON.stringify(userContext)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.result.enabled;\n    }\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.defaultTimeout);\n      const response = await fetch(`${this.baseURL}/${flagId}/evaluate`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(userContext),\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      this.cache.set(cacheKey, {\n        result,\n        timestamp: Date.now()\n      });\n      return result.enabled;\n    } catch (error) {\n      console.error(`Error evaluating feature flag '${flagId}':`, error);\n      return false; // Default to disabled on error\n    }\n  }\n\n  /**\n   * Evaluate multiple feature flags at once\n   */\n  async evaluateAllFlags(userContext) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.defaultTimeout);\n      const response = await fetch(`${this.baseURL}/evaluate`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(userContext),\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const results = await response.json();\n      return results;\n    } catch (error) {\n      console.error('Error evaluating feature flags:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Get all available feature flags\n   */\n  async getAllFlags() {\n    try {\n      const response = await fetch(`${this.baseURL}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const flags = await response.json();\n      return flags;\n    } catch (error) {\n      console.error('Error fetching feature flags:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get a specific feature flag\n   */\n  async getFlag(flagId) {\n    try {\n      const response = await fetch(`${this.baseURL}/${flagId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 404) {\n          return null;\n        }\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const flag = await response.json();\n      return flag;\n    } catch (error) {\n      console.error(`Error fetching feature flag '${flagId}':`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache() {\n    this.cache.clear();\n  }\n\n  /**\n   * Set cache timeout\n   */\n  setCacheTimeout(timeout) {\n    this.cacheTimeout = timeout;\n  }\n\n  /**\n   * Set request timeout\n   */\n  setRequestTimeout(timeout) {\n    this.defaultTimeout = timeout;\n  }\n\n  /**\n   * Check if service is healthy\n   */\n  async healthCheck() {\n    try {\n      const response = await fetch(`${this.baseURL}/health`, {\n        method: 'GET'\n      });\n      return response.ok;\n    } catch (error) {\n      console.error('Feature flags service health check failed:', error);\n      return false;\n    }\n  }\n}\n\n// Export singleton instance\nexport default new FeatureFlagService();\n\n// Export class for custom instances\nexport { FeatureFlagService };","map":{"version":3,"names":["FeatureFlagService","constructor","baseURL","cache","cacheTimeout","defaultTimeout","Map","evaluateFlag","flagId","userContext","cacheKey","JSON","stringify","cached","get","Date","now","timestamp","result","enabled","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","method","headers","body","signal","clearTimeout","ok","Error","status","json","set","error","console","evaluateAllFlags","results","getAllFlags","flags","getFlag","flag","clearCache","clear","setCacheTimeout","timeout","setRequestTimeout","healthCheck"],"sources":["/Users/macbookpro2017/Documents/GitHub/elotusteam-alogth/hackathon/microservice-project/frontend/src/services/featureFlags.ts"],"sourcesContent":["// Feature Flags Service for Frontend Integration\n// TypeScript implementation with React support\n\nexport interface UserContext {\n  user_id?: string;\n  email?: string;\n  ip_address?: string;\n  user_agent?: string;\n  attributes?: Record<string, any>;\n}\n\nexport interface FeatureFlagResult {\n  enabled: boolean;\n  variant?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface FeatureFlag {\n  id: string;\n  name: string;\n  description: string;\n  enabled: boolean;\n  rollout: number;\n  environment: string;\n  service: string;\n  created_at: string;\n  updated_at: string;\n}\n\nclass FeatureFlagService {\n  private baseURL: string;\n  private cache: Map<string, { result: FeatureFlagResult; timestamp: number }>;\n  private cacheTimeout: number;\n  private defaultTimeout: number;\n\n  constructor(baseURL = '/api/v1/flags') {\n    this.baseURL = baseURL;\n    this.cache = new Map();\n    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes\n    this.defaultTimeout = 3000; // 3 seconds\n  }\n\n  /**\n   * Evaluate a single feature flag\n   */\n  async evaluateFlag(\n    flagId: string,\n    userContext: UserContext\n  ): Promise<boolean> {\n    const cacheKey = `${flagId}-${JSON.stringify(userContext)}`;\n    const cached = this.cache.get(cacheKey);\n\n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.result.enabled;\n    }\n\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.defaultTimeout);\n\n      const response = await fetch(`${this.baseURL}/${flagId}/evaluate`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(userContext),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result: FeatureFlagResult = await response.json();\n\n      this.cache.set(cacheKey, {\n        result,\n        timestamp: Date.now(),\n      });\n\n      return result.enabled;\n    } catch (error) {\n      console.error(`Error evaluating feature flag '${flagId}':`, error);\n      return false; // Default to disabled on error\n    }\n  }\n\n  /**\n   * Evaluate multiple feature flags at once\n   */\n  async evaluateAllFlags(\n    userContext: UserContext\n  ): Promise<Record<string, FeatureFlagResult>> {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.defaultTimeout);\n\n      const response = await fetch(`${this.baseURL}/evaluate`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(userContext),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const results: Record<string, FeatureFlagResult> = await response.json();\n      return results;\n    } catch (error) {\n      console.error('Error evaluating feature flags:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Get all available feature flags\n   */\n  async getAllFlags(): Promise<FeatureFlag[]> {\n    try {\n      const response = await fetch(`${this.baseURL}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const flags: FeatureFlag[] = await response.json();\n      return flags;\n    } catch (error) {\n      console.error('Error fetching feature flags:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get a specific feature flag\n   */\n  async getFlag(flagId: string): Promise<FeatureFlag | null> {\n    try {\n      const response = await fetch(`${this.baseURL}/${flagId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        if (response.status === 404) {\n          return null;\n        }\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const flag: FeatureFlag = await response.json();\n      return flag;\n    } catch (error) {\n      console.error(`Error fetching feature flag '${flagId}':`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Set cache timeout\n   */\n  setCacheTimeout(timeout: number): void {\n    this.cacheTimeout = timeout;\n  }\n\n  /**\n   * Set request timeout\n   */\n  setRequestTimeout(timeout: number): void {\n    this.defaultTimeout = timeout;\n  }\n\n  /**\n   * Check if service is healthy\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      const response = await fetch(`${this.baseURL}/health`, {\n        method: 'GET',\n      });\n      return response.ok;\n    } catch (error) {\n      console.error('Feature flags service health check failed:', error);\n      return false;\n    }\n  }\n}\n\n// Export singleton instance\nexport default new FeatureFlagService();\n\n// Export class for custom instances\nexport { FeatureFlagService };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}